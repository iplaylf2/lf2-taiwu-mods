## 📦 非托管供应商依赖 (Unmanaged Vendor Dependencies)

此目录旨在解决部分第三方依赖项无法通过公共 NuGet 源获取的问题。我们通过手动创建 NuGet 包来统一管理这些依赖。

根据法律风险与便利性的权衡，我们提供两种依赖恢复策略：**本地恢复**（推荐，最简单）和**私有源恢复**（进阶，适用于团队协作）。

### 🚀 本地打包与恢复（推荐）

此方法将依赖项打包到项目本地的 `nupkg` 目录下，供 `dotnet restore` 直接使用。这是最简单、且能规避法律风险的上手方式。

1.  **准备文件**: 将需要打包的程序集（如 `Taiwu.Backend.dll`）放入对应 `unmanaged-vendor` 项目下的 `lib/` 目录中。如果某个包无需捆绑任何库文件，保持其 `lib/` 目录为空即可。
2.  **打包**: 在**仓库根目录**下运行 `dotnet pack`。该命令会自动打包 `unmanaged-vendor` 目录下的所有项目，并将生成的 `.nupkg` 文件统一输出到根目录的 `nupkg/` 文件夹。
3.  **恢复**: 在**仓库根目录**下运行 `dotnet restore`。NuGet 会自动找到本地 `nupkg/` 目录中的包并完成依赖恢复。

> **💡 提示**
> 即使某个包的 `lib` 目录为空，也必须通过 `dotnet pack` 生成一个对应的空包，否则 `dotnet restore` 将因找不到包而失败。

此方案的优点是完全离线，不涉及任何网络分发，规避了法律风险。缺点是不利于版本管理和团队间的依赖共享。

---

### ☁️ (可选) 使用私有源进行版本管理

对于团队协作或需要严格版本控制的场景，你可以将打包好的 `.nupkg` 文件发布到私有的 NuGet 源，如 GitHub Packages。

- **优点**:
  - **版本控制**: 可以像管理普通 NuGet 包一样管理游戏库的版本。
  - **团队共享**: 团队成员只需配置好凭据，即可通过 `dotnet restore` 自动拉取一致的依赖。
- **配置**:
  本仓库的 `nuget.config` 已预先配置了从 GitHub Packages (`iplaylf2`) 拉取依赖的逻辑。你只需将包发布到对应的私有源即可。

#### ⚠️ 重要声明与风险提示

**免责声明：此方案为社区驱动的变通方法，并非官方支持。使用此目录中的包意味着你理解并接受以下风险。**

1.  **法律风险**
    **我们不在任何公共或私有源上提供游戏核心程序集的包**。重新分发这些文件可能与游戏的最终用户许可协议（EULA）相悖。如果你选择自行发布到私有源，相关行为的合规性风险由你自行承担。

2.  **技术风险**
    - **版本锁定**：这些包与特定版本的游戏或 Unity 编辑器紧密耦合。游戏更新后，这些包必须手动同步更新，否则会导致 Mod 编译失败或运行时崩溃。
    - **维护成本**：维护这些包的同步更新需要持续投入精力。

**总而言之，此目录为处理特殊依赖提供了一套工程化方案，但其本质是脆弱且高风险的。请谨慎使用。**

---

### 🧬 依赖类型与打包策略

无论你选择本地恢复还是私有源，打包的策略都是相同的：

#### 1. 游戏核心程序集（仅供编译）
- **目录**：`game/`
- **依赖示例**：`Taiwu.Backend.dll`, `Taiwu.Frontend.dll`
- **问题**：这些是《太吾绘卷》的游戏核心文件。Mod 开发时需要引用它们来访问游戏 API，但它们不应随 Mod 一起分发。
- **策略**：我们将这些 DLL 打包为“仅编译时”的引用程序集。这意味着，Mod 项目在编译时可以正常链接它们，但在运行时会依赖游戏本身提供的程序集，从而避免重复分发。

#### 2. 第三方库（随 Mod 运行）
- **目录示例**：`upm/`
- **依赖示例**：`UniTask`
- **问题**：部分库（尤其是为 Unity UPM 设计的库）没有官方 NuGet 包，但我们的 Mod 在运行时又需要它们。
- **策略**：我们将这些库打包为标准的 NuGet 包，其 DLL 文件将作为运行时依赖，随 Mod 一同发布。
- **💡 最佳实践**：为避免不同 Mod 之间因携带不同版本的库而产生冲突，强烈建议使用 `ILRepack` 等工具将这类运行时依赖内嵌到你的主程序集中。