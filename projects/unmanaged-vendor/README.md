## 📦 非托管供应商依赖 (Unmanaged Vendor Dependencies)

此目录旨在解决部分第三方依赖项无法通过公共 NuGet 源获取的问题。我们通过提供一套自动化的工作流与工程化的手动打包方案，来统一管理这些依赖。

根据法律风险与便利性的权衡，我们提供两种依赖恢复策略：**自动化私有源恢复**（推荐，适用于绝大多数场景）和**手动本地恢复**（备选，适用于离线环境）。

### 🚀 自动化私有源恢复 (推荐)

对于团队协作或需要进行依赖版本管理的场景，我们推荐使用本仓库提供的自动化工作流。它能将游戏库打包，并作为私有 NuGet 包发布到你自己的 GitHub Packages 源，从而实现可靠的依赖恢复与版本控制。

> **工作流原理**
> 该工作流会从你提供的下载地址获取游戏库的压缩包，然后将其解压至 `projects/unmanaged-vendor/game` 目录。此操作会**覆盖**该目录的现有内容，以确保打包的是你指定的版本。通常，开发者只需关心其中的 `lib` 子目录，因为这里存放了最终用于生成 NuGet 包的程序集文件，具体打包策略见后文。

- **优点**:
  - **版本控制**: 可以像管理普通 NuGet 包一样管理游戏库的版本。
  - **团队共享**: 团队成员只需配置好凭据，即可通过 `dotnet restore` 自动拉取一致的依赖。
  - **一键发布**: 无需手动下载、打包、上传，工作流会自动处理所有步骤。
- **使用步骤**:
  1.  **创建你的仓库**: 将本仓库作为模板 (Use this template) 或直接 Fork 来创建你自己的仓库。
  2.  **运行工作流**: 在你的仓库 `Actions` 页面找到 `Pack and Publish Game Libraries` 工作流。
  3.  **提供参数并执行**: 根据工作流的提示，提供游戏库的下载地址和版本号，然后运行它。工作流会自动将打包好的 `.nupkg` 文件发布到你账户的 GitHub Packages。
  4.  **配置 `nuget.config`**: 在根目录的 `nuget.config` 文件中，**新增**一个指向你个人 GitHub Packages 的包源，用于恢复私有游戏依赖。请务必保留已有的 `iplaylf2` 源，因为它包含了必要的开源辅助包。

---

### ✋ (备选) 手动本地打包与恢复

此方法将依赖项打包到项目本地的 `.lf2.nupkg` 目录下，供 `dotnet restore` 直接使用。它适用于完全离线的开发环境，或作为快速验证的临时方案。

1.  **准备文件**: 将需要打包的程序集放入对应 `unmanaged-vendor` 项目下的 `lib/` 目录中。如果某个包无需捆绑任何库文件，保持其 `lib/` 目录为空即可。
2.  **打包**: 在**仓库根目录**下运行 `dotnet pack`。该命令会自动打包 `unmanaged-vendor` 目录下的所有项目，并将生成的 `.nupkg` 文件统一输出到根目录的 `.lf2.nupkg/` 文件夹。
3.  **恢复**: 在**仓库根目录**下运行 `dotnet restore`。NuGet 会自动找到本地 `.lf2.nupkg/` 目录中的包并完成依赖恢复。

> **💡 提示**
> 即使某个包的 `lib` 目录为空，也必须通过 `dotnet pack` 生成一个对应的空包，否则 `dotnet restore` 将因找不到包而失败。

此方案的优点是完全离线，不涉及任何网络分发。缺点是不利于版本管理和团队间的依赖共享。

---

### ⚠️ 重要声明与风险提示

**免责声明：此方案为社区驱动的变通方法，并非官方支持。使用此目录中的包意味着你理解并接受以下风险。**

1.  **法律风险**
    **本模板仓库不托管任何游戏核心程序集的包**。重新分发这些文件可能与游戏的最终用户许可协议（EULA）相悖。如果你选择自行发布到私有源，相关行为的合规性风险由你自行承担。

2.  **技术风险**
    - **版本锁定**：这些包与特定版本的游戏或 Unity 编辑器紧密耦合。游戏更新后，这些包必须手动同步更新，否则会导致 Mod 编译失败或运行时崩溃。
    - **维护成本**：维护这些包的同步更新需要持续投入精力。

**总而言之，此目录为处理特殊依赖提供了一套工程化方案，但其本质是脆弱且高风险的。请谨慎使用。**

---

### 🧬 依赖类型与打包策略

无论你选择哪种恢复方案，打包的策略都是相同的：

#### 1. 游戏核心程序集（仅供编译）
- **目录示例**：`game/Taiwu.Backend/lib/`
- **依赖示例**：`GameData.dll`, `GameData.Shared.dll`
- **问题**：这些是《太吾绘卷》的游戏核心文件。Mod 开发时需要引用它们来访问游戏 API，但它们不应随 Mod 一起分发。
- **策略**：我们将这些 DLL 打包为“仅编译时”的引用程序集。这意味着，Mod 项目在编译时可以正常链接它们，但在运行时会依赖游戏本身提供的程序集，从而避免重复分发。

#### 2. 第三方库（随 Mod 运行）
- **目录示例**：`upm/UniTask/lib/`
- **依赖示例**：`UniTask.dll`
- **问题**：部分库（尤其是为 Unity UPM 设计的库）没有官方 NuGet 包，但我们的 Mod 在运行时又需要它们。
- **策略**：我们将这些库打包为标准的 NuGet 包，其 DLL 文件将作为运行时依赖，随 Mod 一同发布。
- **💡 最佳实践**：为避免不同 Mod 之间因携带不同版本的库而产生冲突，强烈建议使用 `ILRepack` 等工具将这类运行时依赖内嵌到你的主程序集中。