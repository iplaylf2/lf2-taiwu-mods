# 📦 非托管供应商依赖 (Unmanaged Vendor Dependencies)

此目录旨在解决部分第三方依赖项无法通过公共 NuGet 源获取的问题。我们通过手动或自动化的方式，将这些依赖打包成 NuGet 包，以供项目恢复。

## ⚠️ 重要声明与风险提示

**免责声明：在继续之前，请务必阅读并理解以下风险。此方案为社区驱动的变通方法，并非官方支持。**

1. **法律风险**
    **本模板仓库不托管任何游戏核心程序集的包**。重新分发这些文件可能与游戏的最终用户许可协议（EULA）相悖。如果你选择自行打包或发布，相关行为的合规性风险由你自行承担。

2. **技术风险**
    - **版本锁定**：这些包与特定版本的游戏或 Unity 编辑器紧密耦合。游戏更新后，这些包必须手动同步更新，否则会导致 Mod 编译失败或运行时崩溃。
    - **维护成本**：维护这些包的同步更新需要持续投入精力。

---

## 🚀 快速上手：本地打包与恢复

此方法是解决游戏核心程序集依赖问题的最直接方案。它将这些依赖打包到项目本地的 `.lf2.nupkg` 目录下，供 `dotnet restore` 直接使用，从而避免了它们的网络分发。

1. **准备文件**: 将需要打包的程序集（DLL文件）放入对应 `unmanaged-vendor` 项目下的 `lib/` 目录中。关于具体哪些文件应放入哪个目录，请参阅末尾的[设计细节](#-设计细节依赖类型与打包策略)章节。
2. **打包**: 在**仓库根目录**下运行 `dotnet pack`。此命令会将 `unmanaged-vendor` 目录下的所有项目打包至 `.lf2.nupkg/` 文件夹。
3. **启用本地源**: 在**仓库根目录**下运行 `dotnet nuget enable source local`。由于本地源默认禁用，此步骤是**必需的**。
4. **恢复**: 在**仓库根目录**下运行 `dotnet restore`。NuGet 会自动找到本地包并完成依赖恢复。

> [!TIP]
> `dotnet pack` 命令会一次性处理所有 `unmanaged-vendor` 项目。`lib` 目录为空的项目也会被正常打包成一个空包，以确保 `dotnet restore` 能够顺利执行。

---

## 🛠️ 进阶指南：自动化与私有源

对于团队协作或任何希望进行依赖版本管理的场景，我们推荐使用本仓库提供的自动化工作流，它是一个更高级的替代方案。它能将游戏库打包，并作为私有 NuGet 包发布到你自己的 GitHub Packages 源。

> [!WARNING]
> **方案互斥**
> 本进阶方案与“快速上手”中的本地方案是互斥的。如果你之前使用了本地打包方案，请务必在切换到本方案前运行 `dotnet nuget disable source local` 禁用本地源，否则可能导致依赖恢复失败。

- **优点**:
  - **版本控制**: 可以像管理普通 NuGet 包一样管理游戏库的版本。
  - **团队共享**: 团队成员只需配置好凭据，即可通过 `dotnet restore` 自动拉取一致的依赖。
  - **一键发布**: 无需手动下载、打包、上传，工作流会自动处理所有步骤。

### 📤 发布到私有源

1. **创建你的仓库**: 将本仓库作为模板 (Use this template) 或直接 Fork 来创建你自己的仓库。
2. **配置仓库机密**: 为避免在日志中暴露下载地址，工作流将从名为 `LF2_GAME_LIBS_URL` 的[仓库机密](https://docs.github.com/zh/actions/security-guides/encrypted-secrets#creating-encrypted-secrets-for-a-repository)中读取游戏库的下载地址。请预先在你的仓库中设置该机密。
3. **运行工作流**: 在你的仓库 `Actions` 页面找到 `Pack and Publish Game Libraries` 工作流。
4. **提供参数并执行**: 根据工作流的提示，仅需提供游戏库的**版本号**即可。工作流将自动处理您所提供的压缩包，请确保包内文件已遵循 `projects/unmanaged-vendor/game` 的目录结构放置。

> [!NOTE]
> **工作流可能不会立即显示**
> 由于 [GitHub 的一个已知问题](https://github.com/orgs/community/discussions/25219)，基于模板创建的仓库，其工作流（Workflows）可能不会自动出现在 `Actions` 页面。如果 `Pack and Publish Game Libraries` 工作流没有显示，你可能需要对工作流文件（例如，在 `.github/workflows/` 目录下）进行一次重命名（或任意修改）并提交，才能触发 GitHub Actions 的识别。

> [!TIP]
> 在第 3 步中，工作流打包前的文件覆盖行为可用于实现深度定制。详情请参阅本章末尾的“通过物料覆盖进行深度定制”小节。

### ⚙️ 配置开发环境以使用私有源

当你的私有源上已经有打包好的游戏依赖后，你和其他团队成员便需要配置本地环境来使用它。

这通常只需要在根目录的 `nuget.config` 文件中，**新增**一个指向你个人 GitHub Packages 的包源即可。

### 🔧 通过物料覆盖进行深度定制

自动化工作流在执行 `dotnet pack` 之前，会先将用户提供的游戏库压缩包解压并覆盖到 `projects/unmanaged-vendor/game` 目录。这个“覆盖”行为是可供高级用户利用的干预点。

除了基础的 DLL 文件外，你还可以在压缩包内遵循 `game` 目录的结构，附带任何你想覆盖的文件——例如，修改过的 `.csproj` 文件，甚至是C#源码（`.cs`文件），从而在不修改 Git 仓库本身的情况下，实现对打包过程的深度定制。

> [!WARNING]
> 此功能非常强大，但也是一把双刃剑，推荐仅用于快速原型验证或个人实验。对于更通用的流程改进或Bug修复，通过代码（而非物料覆盖）来解决，是更可持续、更便于协作的工程实践。

---

## 🧬 设计细节：依赖类型与打包策略

无论你选择哪种恢复方案，打包的策略都是相同的。理解这一策略有助于你进行更深度的定制。

## 🧱 1. 游戏核心程序集（仅供编译）

- **目录示例**：`game/Taiwu.Backend/lib/`
- **依赖示例**：`GameData.dll`, `GameData.Shared.dll`
- **问题**：这些是《太吾绘卷》的游戏核心文件。Mod 开发时需要引用它们来访问游戏 API，但它们不应随 Mod 一起分发。
- **策略**：我们将这些 DLL 打包为“仅编译时”的引用程序集。这意味着，Mod 项目在编译时可以正常链接它们，但在运行时会依赖游戏本身提供的程序集，从而避免重复分发。

## 🧩 2. 第三方库（随 Mod 运行）

- **目录示例**：`upm/UniTask/lib/`
- **依赖示例**：`UniTask.dll`
- **问题**：部分库（尤其是为 Unity UPM 设计的库）没有官方 NuGet 包，但我们的 Mod 在运行时又需要它们。
- **策略**：我们将这些库打包为标准的 NuGet 包，其 DLL 文件将作为运行时依赖，随 Mod 一同发布。

> [!NOTE]
> 本仓库提供的 `pack-and-publish-game-libs` 自动化工作流**不处理**此类第三方库的打包与发布，它仅针对 `game/` 目录下的游戏核心程序集。这类库通常需要开发者自行获取其 DLL，并手动发布到私有源。
> 此外，请确保您使用的 UPM 包（或其DLL）是针对与游戏兼容的 Unity 版本编译的，以避免运行时发生兼容性错误。

> [!TIP]
> 为避免不同 Mod 之间因携带不同版本的库而产生冲突，强烈建议使用 `ILRepack` 等工具将这类运行时依赖内嵌到你的主程序集中。
